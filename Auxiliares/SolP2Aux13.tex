    
     \documentclass[dcc,sol]{fcfmcourse}
    \usepackage{teoria}
    \usepackage[utf8x]{inputenc}
    \usepackage{amsmath}
    \usepackage{amsfonts,setspace}
    \usepackage{listings}
    \usepackage{color}
    
    \usepackage{tikz}
    
    \usepackage{verbatim}
    \usetikzlibrary{arrows,shapes}
    
    \definecolor{pblue}{rgb}{0.13,0.13,1}
    \definecolor{pgreen}{rgb}{0,0.5,0}
    \definecolor{porange}{rgb}{0.9,0.5,0}
    \definecolor{pgrey}{rgb}{0.46,0.45,0.48}
    
    \lstset{language=Java,
      showspaces=false,
      showtabs=false,
      breaklines=true,
      showstringspaces=false,
      breakatwhitespace=true,
      commentstyle=\color{porange},
      keywordstyle=\color{pblue},
      stringstyle=\color{pgreen},
      basicstyle=\ttfamily,
      moredelim=[il][\textcolor{pgrey}]{$ $},
      moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
    }
    
    \newenvironment{codebox} {\small \ttfamily \obeylines \begingroup \setstretch{-2.4}} {\endgroup}
    
    \title{Auxiliar 13 - Búsqueda y Compresión de Texto}
    \course[CC3001]{Algoritmos y Estructuras de Datos}
    \professor{Nelson Baloian}
    \professor{Patricio Poblete}
    \assistant{Gabriel Azócar, Manuel Cáceres}
    \assistant{Michel Llorens, Sergio Peñafiel}
    
    
    \begin{document}
    \maketitle
    
    \vspace{-1ex}
    
    
    \begin{problems}
    
    \problem
    
    \problem
    \begin{enumerate}[a)]
        \item El resultado es $(0,0,a)(0,0,b)(1,1,a)(2,2,b)(2,4,null)$
        \item El resultado es $(0,0,a)(1,10,null)$ :O
        \item $T[j+1]$ enviado sin codificar es importante pues si el algoritmo no encuentra ningún prefijo de lo que queda como aparición anterior igual debe avanzar en el texto. LZW soluciona este fenómeno precargando la codificación de todos los símbolos del alfabeto, de esta forma siempre al menos un símbolo solitario hará match en el diccionario.
        \item Cuando $n$ es muy grande y se está procesando el final del string debemos buscar entre todos los substrings posibles de un texto gigante que podría llegar a tener un costo muy grande.\\
        Para solucionar este inconveniente no buscamos el string en todo el texto que hayamos leído, sino que solo en una ventana de largo fijo hacia atrás; de esta manera tenemos que revisar una cantidad $\mathcal{O}(1)$ de substrings, por lo que el algoritmo es $\mathcal{O}(n)$. Esta es una variante de Lempel-Ziv denominada LZ77.
    \end{enumerate}
    \end{problems}
    \end{document}
